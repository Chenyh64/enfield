#ifndef __EFD_QBIT_ALLOCATOR_H__
#define __EFD_QBIT_ALLOCATOR_H__

#include "enfield/Arch/ArchGraph.h"
#include "enfield/Transform/DependencyBuilderPass.h"
#include "enfield/Support/CommandLine.h"
#include "enfield/Support/Stats.h"

namespace efd {
    /// \brief Struct used to describe the operation chosen for each solving each
    /// dependency.
    ///
    /// Probably we should construct an union for all operations. For the time being,
    /// only the lcnot uses more than one property.
    struct Operation {
        /// \brief Kinds of operations available.
        enum Kind {
            K_OP_CNOT,
            K_OP_REV,
            K_OP_LCNOT,
            K_OP_SWAP
        };

        Kind mK;
        uint32_t mU, mV;
        /// \brief The intermediate vertex for using the long cnot.
        uint32_t mW;
    };

    /// \brief The solution for the allocation problem.
    ///
    /// It consists in an initial mapping L:P->V (\em mInitial), a sequence of sequences
    /// of operations previously defined (\em mOpSeqs) and the final cost (\em mCost).
    struct Solution {
        typedef std::vector<Operation> OpVector;
        typedef std::vector<std::pair<Node::Ref, OpVector>> OpSequences;
        typedef std::vector<uint32_t> Mapping;

        Mapping mInitial;
        OpSequences mOpSeqs;
        uint32_t mCost;
    };

    /// \brief Base abstract class that allocates the qbits used in the program to
    /// the qbits that are in the physical architecture.
    class QbitAllocator : public PassT<Solution> {
        public:
            typedef QbitAllocator* Ref;
            typedef std::unique_ptr<QbitAllocator> uRef;

            typedef Solution::Mapping Mapping;
            typedef std::vector<std::string> BasisVector;
            typedef DependencyBuilder::DepsSet DepsSet;
            typedef DependencyBuilder::DepsSet::iterator Iterator;

        private:
            /// \brief Inlines all gates, but those flagged.
            void inlineAllGates();

            /// \brief Replace all qbits from the program with the architecture's qbits. 
            void replaceWithArchSpecs();

            /// \brief Rename all the qbits, taking into account the \em mMapping, and
            /// the swaps generated by the compiler.
            void renameQbits();

        protected:
            bool mInlineAll;
            ArchGraph::sRef mArchGraph;
            BasisVector mBasis;
            QModule::Ref mMod;

            uint32_t mVQubits;
            uint32_t mPQubits;

            QbitAllocator(ArchGraph::sRef archGraph);

            /// \brief Executes the allocation algorithm after the preprocessing.
            virtual Solution executeAllocation(QModule::Ref qmod) = 0;

        public:
            bool run(QModule::Ref qmod) override;

            /// \brief Flags the QbitAllocator to inline all gates, but those inside the
            /// \p basis vector, before mapping.
            void setInlineAll(BasisVector basis = {});
            /// \brief Flags the QbitAllocator not to inline.
            void setDontInline();
    };

    /// \brief Generates an assignment mapping (maps the architecture's qubits
    /// to the logical ones) of size \p archQ.
    Assign GenAssignment(uint32_t archQ, Mapping mapping, bool fill = true);

    /// \brief Fills the unmapped qubits with the ones missing.
    void Fill(uint32_t archQ, Mapping& mapping);
    void Fill(Mapping& mapping, Assign& assign);

    /// \brief Returns an identity mapping.
    Mapping IdentityMapping(uint32_t progQ);

    /// \brief Prints the mapping \p m to a string and returns it.
    std::string MappingToString(Mapping m);
}

extern efd::Stat<uint32_t> TotalCost;
extern efd::Opt<uint32_t> SwapCost;
extern efd::Opt<uint32_t> RevCost;
extern efd::Opt<uint32_t> LCXCost;

#endif
