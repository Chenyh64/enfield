\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true}

\makeatletter\if@ACM@journal\makeatother

\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother

\acmConference[PL'18]{International Symposium on Code Generation and Optimization}{February 24--28th, 2018}{Vienna, Austria}
\acmYear{2018}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi

\setcopyright{none}             %% For review submission

\bibliographystyle{ACM-Reference-Format}

\citestyle{acmauthoryear}   %% For author/year citations

\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage[amsmath]{ntheorem}
\usepackage{dsfont}
\usepackage{float}
\usepackage{graphicx}
\usepackage{lineno}
\usepackage{paralist}
\usepackage{multirow}
\usepackage{pbox}
%\usepackage{hyperref}
\usepackage{proof}
\usepackage{url}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[lined,algonl,boxed]{algorithm2e}
\usepackage{thmtools}
\usepackage{listings}
\usepackage{makecell}

\def\qed{\unskip\kern 10pt{\unitlength1pt\linethickness{.4pt}\framebox(6,6){}}}

\newcommand{\cm}[1]{\mbox{\textsf{CM}$_{#1}$}}
\newcommand{\cg}[1]{\mbox{\textsf{CG}$_{#1}$}}
\newcommand{\ecd}[1]{\mbox{\textsf{ECG}$_{#1}$}}
\newcommand{\ssp}{\mbox{\textsf{SSP}}}
\newcommand\pgcc{\mbox{\textsf{pgcc}}}
\newcommand\ppgc{\mbox{\textsf{ppgc}}}
\newcommand\accull{\mbox{\textsf{AccUll}}}


\def\ppcg{\textsf{ppcg}\xspace}
\def\accull{\textsf{AccULL}\xspace}
\def\etino{\textsf{Etino}\xspace}
\def\dawncc{\textsf{dawncc}\xspace}

\begin{document}

\title{QBit Allocation}
% \subtitle{Subtitle Text, if any}

\author{Marcos Yukio Siraichi}
\affiliation{
  \department{Computer Science}
  \institution{Universidade Federal de Minas Gerais}
  \streetaddress{Avenida Ant\^{o}nio Carlos, 6627}
  \city{Belo Horizonte}
  \state{MG}
  \postcode{31270-901}
  \country{Brazil}
}
\email{yukio.siraichi@dcc.ufmg.br}

\author{Vin\'{i}cius Fernandes dos Santos}
\affiliation{
  \department{Computer Science}
  \institution{Universidade Federal de Minas Gerais}
  \streetaddress{Avenida Ant\^{o}nio Carlos, 6627}
  \city{Belo Horizonte}
  \state{MG}
  \postcode{31270-901}
  \country{Brazil}
}
\email{viniciussantos@dcc.ufmg.br}

\author{Sylvain Collange}
\affiliation{
  \department{Centre de Recherche Rennes}
  \institution{INRIA}
  \streetaddress{Campos de Beaulieu}
  \city{Rennes}
  \state{MG}
  \postcode{35042}
  \country{France}
}
\email{sylvain.collange@inria.fr}

\author{Fernando Magno Quint\~{a}o Pereira}
\affiliation{
  \department{Computer Science}
  \institution{Universidade Federal de Minas Gerais}
  \streetaddress{Avenida Ant\^{o}nio Carlos, 6627}
  \city{Belo Horizonte}
  \state{MG}
  \postcode{31270-901}
  \country{Brazil}
}
\email{fernando@dcc.ufmg.br}

%\thanks{XX}                %% \thanks is optional


\begin{abstract}
In May of 2016, IBM Research has made a quantum processor available to the
general public in the cloud.
The possibility of programming an actual quantum device has elicited much
enthusiasm.
Yet, quantum programming still lacks abstractions, and all the compiler
support that modern programming languages enjoy today.
To use the IBM Quantum Experience, programmers must design low-level circuits.
In particular, they must map logical qbits into physical qbits, a task that
resembles the early days of programming, in which software was built in
machine languages.
In this paper, we formally introduce the qbit allocation problem and provide an
exact solution to it.
This optimal algorithm deals with the simple quantum machinery available
today; however, it cannot scale up to the more complex architectures that are
scheduled to appear.
Thus, we also provide a heuristic solution to qbit allocation, which outperforms
the current solutions already implemented to deal with this problem.
\end{abstract}

 \begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10010520.10010521.10010542.10010550</concept_id>
<concept_desc>Computer systems organization~Quantum computing</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10010583.10010786.10010813</concept_id>
<concept_desc>Hardware~Quantum technologies</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10002950.10003624.10003625.10003630</concept_id>
<concept_desc>Mathematics of computing~Combinatorial optimization</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10003752.10003809.10011254</concept_id>
<concept_desc>Theory of computation~Algorithm design techniques</concept_desc>
<concept_significance>100</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Quantum computing}
\ccsdesc[500]{Hardware~Quantum technologies}
\ccsdesc[300]{Mathematics of computing~Combinatorial optimization}
\ccsdesc[100]{Theory of computation~Algorithm design techniques}

\maketitle

\keywords{keyword1, keyword2, keyword3}  %% \keywords is optional

\section{Introduction}
\label{sec:intro}

With the recent introduction of cloud access to quantum computer prototypes,
experimental quantum computing (QC) is now available to a wide community.
For instance, the IBM Quantum Experience
program\footnote{\url{http://research.ibm.com/ibm-q/}} lets users submit
experiments based on either a visual circuit representation or a gate-level
language based on MIT Quantum Assembler (QASM) syntax~\cite{Cross17,Svore06}.
However, the level of abstraction offered by quantum circuits is low, and 
circuits need to obey machine-specific constraints.
Consequently, manual mapping and tuning of QC algorithms in QASM is tedious and
error-prone.

To compound the issue, today's quantum computer prototypes have tight resource
constraints.
For instance, the IBM 5Q computer supports at most 5 qubits with limited
connectivity.
In addition, decoherence severely constrain the execution time.
Although quantum error-correcting codes (QEC) may mitigate the decoherence
issue, current hardware do not provide enough resources for realistic
QEC~\cite{Cross17}.
The longer a quantum program runs, the more it is susceptible to noise.
Therefore, minimizing runtime is crucial as the accuracy of the results depends
on it.
Thus, compilation of quantum circuits demands extremely accurate compiler 
optimization.

Developers write quantum programs by designing quantum circuits.
These circuits manipulate {\em qbits} -- the quantum analogue of the classical
bit.
These qbits, which exist as abstractions within a quantum circuit, shall be
called {\em virtual} or {\em logical}.
In this paper, we are interested in mapping {\em virtual qbits}
into {\em physical qbits}, which denote the actual hardware units that store
quantum bits.
This problem henceforth shall be called {\em qbit allocation}.
Just like registers, in a classic computer architecture, quantum computers
have a limited number of qbits.
Furthermore, these units are not fully connected, meaning that not every
subset of physical qbits can participate as inputs and outputs to the same
quantum gates.
As we explain in Section~\ref{sec:ovr}, solving qbit allocation involves
dealing with hard combinatorial problems.

In this paper, we formally describe the qbit allocation problem in
Section~\ref{sub:prob}, and introduce an exact solution to solve it in
Section~\ref{sub:exact}.
The exact solution is exponential.
Although it works well for the small quantum systems available today, it cannot
scale up to the more complex architectures that are likely to emerge in the
future.
Nevertheless, it sets a mark against which we can test different heuristics.
To support this statement, we show how state-of-the-art implementations of qbit
allocators fare against this exact baseline.
This comparison has motivated us to go beyond these implementations;
a task that we accomplish with a novel allocator of our own craft, which we
introduce in Section~\ref{sub:heu}.

Section~\ref{sec:eval} provides a thorough evaluation of the different
algorithms that exist today to perform qbit allocation.
One of the complications that we had to handle in this empirical evaluation was
a shortage of benchmarks.
Being a new addition to the family of hard machines available today, the IBM
Quantum Computer has a minuscule community of users, which is essential for
building software to it.
We have assembled a small collection of benchmarks that solve known quantum
algorithms, and have implemented a generator of random programs.
Together, the actual and synthetic benchmarks gives us a number of samples
that is comprehensive enough to test our ideas, and demonstrate their
effectiveness.

\section{Overview}
\label{sec:ovr}

% Describe a quantum circuit.

% Describe the gates that constitute it.

% Describe the quantum architecture

% Announce the problem.

% Explain the problem with an example.

\section{Solution}
\label{sec:sol}

\subsection{Problem Definition}
\label{sub:prob}

\subsection{Exact Solution}
\label{sub:exact}

\subsection{Heuristics}
\label{sub:heu}

\section{Evaluation}
\label{sec:eval}

\section{Related Work}
\label{sec:rw}

\section{Conclusion}
\label{sec:conc}


%\bibliographystyle{abbrvnat}
\bibliography{refs}

\end{document}
